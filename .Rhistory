rgl.points(x,y,z)
axes3d()
require(rgl)
rho = 100
theta = seq(0, pi, length.out = 90)
phi = seq(0, pi/2, length.out = 90)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
clear3d()
rgl.points(x,y,z)
axes3d()
rho = 100
theta = seq(0, pi, length.out = 90)
phi = seq(0, pi, length.out = 90)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
clear3d()
rgl.points(x,y,z)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
clear3d()
rgl.points(x,y,z)
axes3d()
lim = 450
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
lim = 300
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
rho = 100
theta = seq(0, pi/2, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
lim = 300
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
lim = 900
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi/4, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
lim = 900
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
range(theta)
range(phi)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi/4, length.out = 30)
range(phi)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi/4, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
apply(coords, 2, range)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
lim = 900
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi/4, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
lim = 900
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
lim = 900
clear3d()
rgl.points(x[1:lim],y[1:lim],z[1:lim])
axes3d()
beg = 200
lim = 900
clear3d()
rgl.points(x[beg:lim],y[beg:lim],z[beg:lim])
axes3d()
beg = 300
lim = 900
clear3d()
rgl.points(x[beg:lim],y[beg:lim],z[beg:lim])
axes3d()
beg = 300
lim = 600
clear3d()
rgl.points(x[beg:lim],y[beg:lim],z[beg:lim])
axes3d()
require(rgl)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
rbind(coords, x=c(x,x), y=c(y,-y), z=c(z,z))
coords = rbind(coords, x=c(x,x), y=c(y,-y), z=c(z,z))
detach(coords)
clear3d()
rgl.points(coords[,4:6])
require(rgl)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
coords = cbind(coords, x=c(x,x), y=c(y,-y), z=c(z,z))
detach(coords)
require(rgl)
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
coords = cbind(coords, x=c(x,x), y=c(y,-y), z=c(z,z))
coords = dta.frame(x=c(x,x), y=c(y,-y), z=c(z,z))
rho = 100
theta = seq(0, pi, length.out = 30)
phi = seq(0, pi, length.out = 30)
coords = expand.grid(rho=rho, theta=theta, phi=phi)
rm(rho, theta, phi)
attach(coords)
x = rho * sin(phi) * cos(theta)
y = rho * sin(phi) * sin(theta)
z = rho * cos(phi)
detach(coords)
coords = data.frame(x=c(x,x), y=c(y,-y), z=c(z,z))
clear3d()
rgl.points(coords)
axes3d()
plot(y=1:100, x=sqrt(100^2 - y^2))
1:100^2
(1:100)^2
plot(y=1:100, x=sqrt(100^2 - (1:100)^2))
plot(y=1:100, x=sqrt(100^2 - (1:100)^2), asp=T)
data()
volcano
Nile
CO2
install.packages("tensorflow")
require(TreeLS)
circlefit
xyz = cyl(300, 1, .5, .05)
plot(xyz)
xp = xyz[,1]
yp = xyz[,2]
p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
p
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
r
cerr <- function(v) sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n)
cerr(r)
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
cerr <- function(v) sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n)
cerr(r)
n = length(yp)
p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
cerr <- function(v) sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n)
cerr(r)
cerr <- sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n)
cerr
r
p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
cerr <- sqrt(sum((sqrt((xp - r[1])^2 + (yp - r[2])^2) - r[3])^2)/n)
cerr
p
p
circlefit(xp, yp)
cerr
p
r
p
circlefit(xp, yp)
r
points(r[1], r[2], col='red')
r2 = circlefit(xp, yp)
points(r2[1], r2[2], col='blue')
r2 = circlefit(xp, yp)
points(r2[1], r2[2], col='blue')
plot(yp ~ xp)
points(r[1], r[2], col='red')
points(r2[1], r2[2], col='blue')
lines(c(r[1], r[1]+r[3]), c(r[2], r[2]), col='red')
lines(c(r2[1], r2[1]+r2[3]), c(r2[2], r2[2]), col='blue')
r == r2
r
r2
r ; cerr
r2
xyz = cyl(300, 1, .5, .05)
xyz[,1] = xyz[,1] + 7
xyz[,2] = xyz[,2] -3
xp = xyz[,1]
yp = xyz[,2]
n = lengt
n = length(yp)
xyz = cyl(300, 1, .5, .05)
xyz[,1] = xyz[,1] + 7
xyz[,2] = xyz[,2] -3
xp = xyz[,1]
yp = xyz[,2]
n = length(yp)
p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
cerr <- sqrt(sum((sqrt((xp - r[1])^2 + (yp - r[2])^2) - r[3])^2)/n)
r2 = circlefit(xp, yp)
xyz = cyl(300, 1, .5, .05)
xyz[,1] = xyz[,1] + 7
xyz[,2] = xyz[,2] -3
xp = xyz[,1]
yp = xyz[,2]
n = length(yp)
p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
r <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
cerr <- sqrt(sum((sqrt((xp - r[1])^2 + (yp - r[2])^2) - r[3])^2)/n)
r2 = circlefit(xp, yp)
plot(yp ~ xp)
points(r[1], r[2], col='red')
points(r2[1], r2[2], col='blue')
lines(c(r[1], r[1]+r[3]), c(r[2], r[2]), col='red')
lines(c(r2[1], r2[1]+r2[3]), c(r2[2], r2[2]), col='blue')
c(r, cerr)
r2
gc()
# install and load necessary packages
if(!require(rgl)){
install.packages('rgl')
require(rgl)
}
if(!require(lidR)){
install.packages('lidR')
require(lidR)
}
# function for plotting 3d cylinders
plotCylinder = function(xCenter = 0, yCenter = 0, hBase = 0, hTop = 1, radius = 0.5, col = 'green'){
axis = matrix(c(
rep(xCenter, 2),
rep(yCenter, 2),
seq(hBase, hTop, length.out = 2)
), ncol = 3, byrow = F)
cyl = cylinder3d(axis, radius = radius)
# shade3d(addNormals(subdivision3d(cyl, depth = 0)), col = col)
mesh = shade3d(cyl, col=col)
}
# set working directory
setwd('C://Work/TLStools/')
# set point cloud name
cloudName = 'sample_data/square.las'
# read the output files generated in the process
cloud = readLAS(cloudName)
treeStats = read.table('square_reslt.txt', head=T)
View(treeStats)
clear3d()
bg3d('black')
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
apply(treeStats, 2, range)
quantile(treeStats$error_ransac, seq(0,1,.1))
treeStats = read.table('square_reslt.txt', head=T)
clear3d()
bg3d('black')
# slow - plot cylinders instead of spheres
apply(treeStats, 1, function(row) plotCylinder(row['x'], row['y'], row['z_min'], row['z_max'], row['rad'], 'yellow'))
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
quantile(treeStats$rad_ransac, seq(0,1,.1))
quantile(treeStats$rad_hough, seq(0,1,.1))
# read the output files generated in the process
cloud = readLAS(cloudName)
stemsCloud = readLAS('square_trees.laz')
layerStack = readLAS('square_segmt.laz')
treeStats = read.table('square_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
bg3d('black')
# --load the points from the detected tree positions on multiple stacked layers
rgl.points(layerStack@data, col='blue')
# --load the stem points
rgl.points(stemsCloud@data, col='darkred')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# set point cloud name
cloudName = 'test_clouds/spain2.laz'
treeStats = read.table('spain2_reslt.txt', head=T)
treeStats = read.table('bin/Release/spain2_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
bg3d('black')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# read the output files generated in the process
cloud = readLAS(cloudName)
# plot the different data
# --open a new rgl device with black background
clear3d()
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
apply(treeStats, range)
apply(treeStats,2,range)
# read the output files generated in the process
cloud = readLAS(cloudName)
treeStats = read.table('bin/Release/spain2_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
bg3d('black')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# set point cloud name
cloudName = 'test_clouds/arvores_teste1.laz'
# read the output files generated in the process
cloud = readLAS(cloudName)
treeStats = read.table('bin/Release/arvores_teste1_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
bg3d('black')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# set point cloud name
cloudName = 'test_clouds/trafospik_plot_9_tree_30.las'
# read the output files generated in the process
cloud = readLAS(cloudName)
treeStats = read.table('bin/Release/trafospik_plot_9_tree_30_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
clear3d()
bg3d('black')
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
getwd()
setwd('test_clouds/')
lasf = readLAS('duratex_p1455_transecto.laz')
lasf = lasclipCircle(lasf, mean(lasf@data$X), mean(lasf@data$Y), radius = 20)
plot(lasf)
lasground_pmf(lasf)
lasground_pmf(lasf, c(1,5,1), c(.3, .2, .2))
plot(lasf, color = 'Classification')
lasf = readLAS('duratex_p1455_transecto.laz')
lasf = lasclipCircle(lasf, mean(lasf@data$X), mean(lasf@data$Y), radius = 20)
lasground_pmf(lasf, c(3,10,3), c(.5, .5, .2))
lasf = readLAS('duratex_p1455_transecto.laz')
apply(lasf@data, 2, range)
nrow(lasf@data)
abs(min(lasf@data$Z))
lasf@data$Z = lasf@data$Z + abs(min(lasf@data$Z))
apply(lasf@data, 2, range)
lasf = readLAS('duratex_p1455_transecto.laz')
lasf = lasclipCircle(lasf, mean(lasf@data$X), mean(lasf@data$Y), radius = 20)
lasf@data$Z = lasf@data$Z + abs(min(lasf@data$Z))
lasground_pmf(lasf, c(3,10,3), c(.5, .5, .2))
lasf = readLAS('duratex_p1455_transecto_n.laz')
lasf = lasclipCircle(lasf, mean(lasf@data$X), mean(lasf@data$Y), radius = 20)
apply(lasf@data, 2, range)
plot(lasf)
require(TreeLS)
lasmat = lasf@data[ lasf@data$Classification != 2 ,]
rgl.points(lasmat)
dim(lasmat)
lasmat = Vfilter(lasmat[,1:3], .5, 50000)
dim(lasmat)
rgl.points(lasmat)
head(lasmat)
relas = LAS(lasmat)
writeLAS(relas, 'duratex_filtered.laz')
writeLAS(lasf, 'duratex_clipped.laz')
gc()
# function for plotting 3d cylinders
plotCylinder = function(xCenter = 0, yCenter = 0, hBase = 0, hTop = 1, radius = 0.5, col = 'green'){
axis = matrix(c(
rep(xCenter, 2),
rep(yCenter, 2),
seq(hBase, hTop, length.out = 2)
), ncol = 3, byrow = F)
cyl = cylinder3d(axis, radius = radius)
# shade3d(addNormals(subdivision3d(cyl, depth = 0)), col = col)
mesh = shade3d(cyl, col=col)
}
# set working directory
setwd('C://Work/TLStools/')
# set point cloud name
cloudName = 'test_clouds/duratex_filtered.laz'
# read the output files generated in the process
cloud = readLAS(cloudName)
stemsCloud = readLAS('bin/Release/duratex_filtered_trees.laz')
layerStack = readLAS('bin/Release/duratex_filtered_segmt.laz')
treeStats = read.table('bin/Release/duratex_filtered_reslt.txt', head=T)
# plot the different data
# --open a new rgl device with black background
clear3d()
bg3d('black')
# --load the points from the detected tree positions on multiple stacked layers
rgl.points(layerStack@data, col='blue')
# --load the stem points
rgl.points(stemsCloud@data, col='darkred')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# plot the different data
# --open a new rgl device with black background
clear3d()
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# --load the stem points
rgl.points(stemsCloud@data, col='darkred', size=.5)
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
cloud = readLAS(cloudName)
stemsCloud = readLAS('bin/Release/duratex_filtered_trees.laz')
layerStack = readLAS('bin/Release/duratex_filtered_segmt.laz')
treeStats = read.table('bin/Release/duratex_filtered_reslt.txt', head=T)
clear3d()
bg3d('black')
# --load the points from the detected tree positions on multiple stacked layers
rgl.points(layerStack@data, col='blue')
# --load the stem points
rgl.points(stemsCloud@data, col='darkred', size=.5)
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# plot the different data
# --open a new rgl device with black background
clear3d()
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x_ransac, y_ransac, (z_min + z_max) / 2, rad_ransac, col='green') )
# --load the stem points
rgl.points(stemsCloud@data, col='darkred', size=.5)
