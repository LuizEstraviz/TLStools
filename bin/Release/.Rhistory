multi = paste(multi[[1]], collapse = ',')
bound = readWKT(paste('MULTIPOLYGON', multi), p4s = "+init=epsg:4326")
}
odbcCloseAll()
bound
prettymap({
plot(bound, axes=T, lwd=ifelse(is.na(brd), 0, 1))
for(i in 1:length(shp)){
plot(shp[[i]], add=T, border=features$cor[i], lwd=3)
}
},
title = 'Plano da Propriedade - Rural Legal',
scale.plotepsg = 4326, scale.padin = c(.05,.05),
scale.labelpadin = .025,
drawarrow = T, arrow.padin = c(.05,.05),
arrow.scale = 1,
mai = rep(.5,4))
is.na(brd)
ifelse(is.na(brd), 0, 1)
plot(bound, axes=T, lwd=ifelse(is.na(brd), 0, 1))
plot(bound, axes=T, lwd=ifelse(is.na(brd), NA, 1))
plot(bound, axes=T, lwd=1)
plot(bound, axes=T, lwd=.1)
plot(bound, axes=T, lwd=0)
plot(bound, axes=T, lwd=NULL)
plot(bound, axes=T, lwd=NA)
plot(bound, axes=T, lty=1)
plot(bound, axes=T, lty=0)
dbhandle = odbcDriverConnect(
'driver={SQL Server};server=18.231.7.174;database=ATER;uid=sa;pwd=Ater_2016#')
baseQuery = "select OBJECTID, idUsuario, flaBorda, nomLocal, idRecomendacao, cor, idBorda, areaHa, Shape.STAsText() as shp from rl.vRLPOLIGONOSAF"
geoQuery = paste(baseQuery, 'where idPlanoPropriedade =', idPlano)
features = sqlQuery(dbhandle, geoQuery, as.is=T)
shp = sapply(features$shp, readWKT, p4s = "+init=epsg:4326")
brd = unique(features$idBorda)
if(!is.na(brd)){
boundQuery = paste(baseQuery, 'where OBJECTID =', brd)
borda = sqlQuery(dbhandle, boundQuery, as.is=T)
bound = readWKT(borda$shp, p4s = "+init=epsg:4326")
}else{
ss = sub(pattern = 'MULTIPOLYGON ', '', features$shp)
multi = paste(ss, collapse = '')
multi = strsplit(multi, '\\)\\(')
multi = paste(multi[[1]], collapse = ',')
bound = readWKT(paste('MULTIPOLYGON', multi), p4s = "+init=epsg:4326")
}
odbcCloseAll()
prettymap({
plot(bound, axes=T, lty=ifelse(is.na(brd), 0, 1))
for(i in 1:length(shp)){
plot(shp[[i]], add=T, border=features$cor[i], lwd=3)
}
},
title = 'Plano da Propriedade - Rural Legal',
scale.plotepsg = 4326, scale.padin = c(.05,.05),
scale.labelpadin = .025,
drawarrow = T, arrow.padin = c(.05,.05),
arrow.scale = 1,
mai = rep(.5,4))
print(getwd())
idPlano = 9
dbhandle = odbcDriverConnect(
'driver={SQL Server};server=18.231.7.174;database=ATER;uid=sa;pwd=Ater_2016#')
baseQuery = "select OBJECTID, idUsuario, flaBorda, nomLocal, idRecomendacao, cor, idBorda, areaHa, Shape.STAsText() as shp from rl.vRLPOLIGONOSAF"
geoQuery = paste(baseQuery, 'where idPlanoPropriedade =', idPlano)
features = sqlQuery(dbhandle, geoQuery, as.is=T)
shp = sapply(features$shp, readWKT, p4s = "+init=epsg:4326")
brd = unique(features$idBorda)
if(!is.na(brd)){
boundQuery = paste(baseQuery, 'where OBJECTID =', brd)
borda = sqlQuery(dbhandle, boundQuery, as.is=T)
bound = readWKT(borda$shp, p4s = "+init=epsg:4326")
}else{
ss = sub(pattern = 'MULTIPOLYGON ', '', features$shp)
multi = paste(ss, collapse = '')
multi = strsplit(multi, '\\)\\(')
multi = paste(multi[[1]], collapse = ',')
bound = readWKT(paste('MULTIPOLYGON', multi), p4s = "+init=epsg:4326")
}
odbcCloseAll()
png(filename = str_c('mapas/',idPlano,'.png'), height = 20, width = 20, units = 'cm', res = 200)
prettymap({
plot(bound, axes=T, lty=ifelse(is.na(brd), 0, 1))
for(i in 1:length(shp)){
plot(shp[[i]], add=T, border=features$cor[i], lwd=3)
}
},
title = 'Plano da Propriedade - Rural Legal',
scale.plotepsg = 4326, scale.padin = c(.05,.05),
scale.labelpadin = .025,
drawarrow = T, arrow.padin = c(.05,.05),
arrow.scale = 1,
mai = rep(.5,4))
idReco = unique(features$idRecomendacao)
par(xpd=TRUE)
legend('topleft',
legend = paste('SAF',ifelse(is.na(idReco), 'não atribuído', idReco)),
fill = NA, border = unique(features$cor))
dev.off()
print(getwd())
getwd()
print(getwd())
version
install.packages("OpenStreetMap")
require(OpenStreetMap)
openmap()
openmap(lat <- c(59.7916,59.6563)
lon <- c(10.0937,10.3293)
map <- openmap(c(lat[1],lon[1]),c(lat[2],lon[2]),zoom=10,'osm')
plot(map))
lat <- c(59.7916,59.6563)
lon <- c(10.0937,10.3293)
map <- openmap(c(lat[1],lon[1]),c(lat[2],lon[2]),zoom=10,'osm')
plot(map)
axes()
axis()
axis(1)
axis(2)
axis(3)
axis(5)
axis(4)
require(stringr)
require(sp)
require(rgdal)
require(lidR)
require(TreeLS)
### funtions
predictTimeStamps = function(gpsVelodyne, gmsList){
charDate = as.character(gpsVelodyne[1,13])
year = 2000 + as.double(substr(charDate, 5,6))
month = as.double(substr(charDate, 3,4))
day = as.double(substr(charDate, 1,2))
weekDay = paste(year, month, day, sep='-')
weekDay = as.double(strftime(weekDay,'%u'))
weekDay = ifelse(weekDay==7,0,weekDay)
charTime = as.character(gpsVelodyne[,5])
hour = as.double(substr(charTime, 1,2))
min  = as.double(substr(charTime, 3,4))
sec  = as.double(substr(charTime, 5,6))
gms  = ((hour*60*60 + min*60 + sec) + weekDay*24*60*60)*1000
gmsToClock = lm(gpsVelodyne[,3] ~ gms)
plot(gpsVelodyne[,3] ~ gms, xlab='GMS', ylab='TimeUS (Velodyne)', pch=20)
abline(gmsToClock, col='red')
estimated = gmsToClock$coefficients[1] + gmsToClock$coefficients[2] * gmsList
names(estimated) = NULL
return(estimated)
}
plotRotationMatrix = function(xyz , gps = c(0,0,0), inflate = c(1,1,1), cols = c('red','green','blue'), ...){
xyz[1,] = inflate[1]*xyz[1,] + gps[1]
xyz[2,] = inflate[2]*xyz[2,] + gps[2]
xyz[3,] = inflate[3]*xyz[3,] + gps[3]
rgl.lines(c(gps[1],xyz[1,1]), c(gps[2],xyz[2,1]), c(gps[3],xyz[3,1]), col=cols[1], ...)
rgl.lines(c(gps[1],xyz[1,2]), c(gps[2],xyz[2,2]), c(gps[3],xyz[3,2]), col=cols[2], ...)
rgl.lines(c(gps[1],xyz[1,3]), c(gps[2],xyz[2,3]), c(gps[3],xyz[3,3]), col=cols[3], ...)
}
clipSphere = function(cloud, rad = 1.5, center = c(0,0,0)) {
if (center[1] == 0 & center[2] == 0) {
dists = sqrt(cloud[,1]^2+cloud[,2]^2+cloud[,3]^2)
out = cloud[dists <= rad, ]
} else {
dists = sqrt(( (cloud[,1]-center[1])^2 + (cloud[,2]-center[2])^2 + (cloud[,3]-center[3])^2 ))
out=cloud[dists<=rad, ]
}
return (out)
}
rotateYAxis = function(pointCloud, angleDegrees=0, axes=c('x','y','z')){
# axVec = if(axis == 'x') c(1,0,0) else if (axis == 'y') c(0,1,0) else c(0,0,1)
angRad = angleDegrees*pi/180
rotMat = matrix(c(
cos(angRad), 0, -sin(angRad),
0,1,0,
sin(angRad), 0, cos(angRad)
), nrow = 3, byrow = T)
newCloud = as.matrix(pointCloud[,axes]) %*% rotMat
pointCloud[,axes] = newCloud
return(pointCloud)
}
flightRotationMatrix = function(yaw, pitch, roll){
alpha = yaw   * pi/180
beta  = pitch * pi/180
gama  = roll  * pi/180
Rz = matrix(c(
cos(alpha) , -sin(alpha), 0,
sin(alpha) , cos(alpha) , 0,
0          , 0          , 1
), ncol=3, byrow = T)
Ry = matrix(c(
cos(beta) , 0, sin(beta),
0         , 1, 0        ,
-sin(beta), 0, cos(beta)
), ncol=3, byrow = T)
Rx = matrix(c(
1,         0, 0         ,
0, cos(gama), -sin(gama),
0, sin(gama), cos(gama)
), ncol=3, byrow = T)
R3d = Rz %*% Ry %*% Rx
return(R3d)
}
logVooFile = '80m_12m.s/2017-12-15 14-08-45.log'
cloudsDir = 'voo6/'
gpsFiles = dir(cloudsDir, pattern = '_gps.txt', full.names = T)
logVoo = read.table(logVooFile, head=F, as.is = T, sep=';')[,1]
gpsVelodyne = lapply(gpsFiles, read.table, header = F, as.is = T, sep=',')
gpsVelodyne = do.call(rbind, gpsVelodyne)
# isolate position and orientation rows
gps = logVoo[grepl('^GPS', logVoo)]
# imu = logVoo[grepl('^IMU,', logVoo)]
att = logVoo[grepl('^ATT', logVoo)]
# parse gps data
gps = as.data.frame(do.call(rbind, strsplit(gps, ', ', fixed = T)))
for(i in 2:ncol(gps)) gps[,i] = as.double(as.character(gps[,i]))
names(gps) = c('Sensor','TimeUS','Status','GMS','GWk','NSats','HDop','Lat','Lng','Alt','Spd','GCrs','VZ','U')
ord = order(gps$TimeUS)
gps = gps[ord,]
# project and convert gps to UTM
latLong = data.frame(lat = gps$Lat, lon = gps$Lng)
coordinates(latLong) = c('lon', 'lat')
proj4string(latLong) <- CRS("+init=epsg:4326")
res = spTransform(latLong, CRS("+init=epsg:22522"))
gps$utmLat = res@coords[,2]
gps$utmLng = res@coords[,1]
# parse attitude (orientation) data
att = as.data.frame(do.call(rbind, strsplit(att, ', ', fixed = T)))
for(i in 2:ncol(att)) att[,i] = as.double(as.character(att[,i]))
names(att) = c('Sensor', 'TimeUS','DesRoll','Roll','DesPitch','Pitch','DesYaw','Yaw','ErrRP','ErrYaw')
# calculate coordinates for each orientation
att = cbind(att, GMS = NA, xPos = NA, yPos = NA, zPos = NA, utmLat = NA, utmLng = NA)
for(i in 2:nrow(gps)){
# i = 2
pos1 = gps[i-1,]
pos2 = gps[i,]
timeDistance = pos2$TimeUS - pos1$TimeUS
# ATT
iRot = which(att$TimeUS < pos2$TimeUS & att$TimeUS >= pos1$TimeUS)
rotations = att[iRot,]
posRotation = (rotations$TimeUS - pos1$TimeUS)/timeDistance
GMS  = pos1$GMS + posRotation * (pos2$GMS - pos1$GMS)
xPos = pos1$Lng + posRotation * (pos2$Lng - pos1$Lng)
yPos = pos1$Lat + posRotation * (pos2$Lat - pos1$Lat)
zPos = pos1$Alt + posRotation * (pos2$Alt - pos1$Alt)
utmLat  = pos1$utmLat + posRotation * (pos2$utmLat - pos1$utmLat)
utmLng  = pos1$utmLng + posRotation * (pos2$utmLng - pos1$utmLng)
att[iRot,c('GMS', 'xPos', 'yPos', 'zPos','utmLat', 'utmLng')] = cbind(GMS, xPos, yPos, zPos, utmLat, utmLng)
}
att = att[!is.na(att$xPos),]
att$velodyneTimeStamp = predictTimeStamps(gpsVelodyne, att$GMS)
# windows()
# par(mfrow=c(1,3))
plot(att$Roll ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Roll, df=100)
lines(spl$x, spl$y, col='red')
att$Roll = spl$y
plot(att$Pitch ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Pitch, df = 100)
lines(spl$x, spl$y, col='red')
att$Pitch = spl$y
roughCh = with(att, which(Yaw[-1] - Yaw[-length(Yaw)] > 10))
roughYaw = att$velodyneTimeStamp[roughCh]
att$Yaw = ifelse(att$velodyneTimeStamp <= roughYaw, att$Yaw+360, att$Yaw)
plot(att$Yaw ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Yaw, df=100)
lines(spl$x, spl$y, col='red')
att$Yaw = spl$y
plot(att$zPos ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$zPos, df=50)
lines(spl$x, spl$y, col='red')
att$zPos = spl$y
rm(gpsVelodyne, gps, latLong, res, logVoo)
# als = read.table('MDT_IPEF_2PTS.xyz')
# clear3d()
# rgl::plot3d(att[,c('utmLng', 'utmLat', 'zPos')], size=3, col='black', aspect = F)
# rgl.points(als, size=.5, col=cloud.col(als, topo.colors, 30))
# read point clouds
cloudFiles = sub(pattern = '_gps', '', gpsFiles)
pointCloud = lapply(cloudFiles, read.table, header = T, colClasses='numeric')
pointCloud = do.call(rbind, pointCloud)
# cross time and gps position
qt = quantile(1:nrow(pointCloud), probs = c(.1,.101))
firstCloud = pointCloud[qt[1]:qt[2],]
azim = firstCloud$azimuth
azim = mean(azim[ azim < 360])
azim = 45
#############################################################################
#
# Important info:
# ATT = flight attitute
# TimeUS = time since the board started running, in micro seconds (US)
# pitch, roll, yaw = degrees
#
#############################################################################
# setwd('../Desktop/eucflux/')
require(stringr)
require(sp)
require(rgdal)
require(lidR)
require(TreeLS)
### funtions
predictTimeStamps = function(gpsVelodyne, gmsList){
charDate = as.character(gpsVelodyne[1,13])
year = 2000 + as.double(substr(charDate, 5,6))
month = as.double(substr(charDate, 3,4))
day = as.double(substr(charDate, 1,2))
weekDay = paste(year, month, day, sep='-')
weekDay = as.double(strftime(weekDay,'%u'))
weekDay = ifelse(weekDay==7,0,weekDay)
charTime = as.character(gpsVelodyne[,5])
hour = as.double(substr(charTime, 1,2))
min  = as.double(substr(charTime, 3,4))
sec  = as.double(substr(charTime, 5,6))
gms  = ((hour*60*60 + min*60 + sec) + weekDay*24*60*60)*1000
gmsToClock = lm(gpsVelodyne[,3] ~ gms)
plot(gpsVelodyne[,3] ~ gms, xlab='GMS', ylab='TimeUS (Velodyne)', pch=20)
abline(gmsToClock, col='red')
estimated = gmsToClock$coefficients[1] + gmsToClock$coefficients[2] * gmsList
names(estimated) = NULL
return(estimated)
}
plotRotationMatrix = function(xyz , gps = c(0,0,0), inflate = c(1,1,1), cols = c('red','green','blue'), ...){
xyz[1,] = inflate[1]*xyz[1,] + gps[1]
xyz[2,] = inflate[2]*xyz[2,] + gps[2]
xyz[3,] = inflate[3]*xyz[3,] + gps[3]
rgl.lines(c(gps[1],xyz[1,1]), c(gps[2],xyz[2,1]), c(gps[3],xyz[3,1]), col=cols[1], ...)
rgl.lines(c(gps[1],xyz[1,2]), c(gps[2],xyz[2,2]), c(gps[3],xyz[3,2]), col=cols[2], ...)
rgl.lines(c(gps[1],xyz[1,3]), c(gps[2],xyz[2,3]), c(gps[3],xyz[3,3]), col=cols[3], ...)
}
clipSphere = function(cloud, rad = 1.5, center = c(0,0,0)) {
if (center[1] == 0 & center[2] == 0) {
dists = sqrt(cloud[,1]^2+cloud[,2]^2+cloud[,3]^2)
out = cloud[dists <= rad, ]
} else {
dists = sqrt(( (cloud[,1]-center[1])^2 + (cloud[,2]-center[2])^2 + (cloud[,3]-center[3])^2 ))
out=cloud[dists<=rad, ]
}
return (out)
}
rotateYAxis = function(pointCloud, angleDegrees=0, axes=c('x','y','z')){
# axVec = if(axis == 'x') c(1,0,0) else if (axis == 'y') c(0,1,0) else c(0,0,1)
angRad = angleDegrees*pi/180
rotMat = matrix(c(
cos(angRad), 0, -sin(angRad),
0,1,0,
sin(angRad), 0, cos(angRad)
), nrow = 3, byrow = T)
newCloud = as.matrix(pointCloud[,axes]) %*% rotMat
pointCloud[,axes] = newCloud
return(pointCloud)
}
flightRotationMatrix = function(yaw, pitch, roll){
alpha = yaw   * pi/180
beta  = pitch * pi/180
gama  = roll  * pi/180
Rz = matrix(c(
cos(alpha) , -sin(alpha), 0,
sin(alpha) , cos(alpha) , 0,
0          , 0          , 1
), ncol=3, byrow = T)
Ry = matrix(c(
cos(beta) , 0, sin(beta),
0         , 1, 0        ,
-sin(beta), 0, cos(beta)
), ncol=3, byrow = T)
Rx = matrix(c(
1,         0, 0         ,
0, cos(gama), -sin(gama),
0, sin(gama), cos(gama)
), ncol=3, byrow = T)
R3d = Rz %*% Ry %*% Rx
return(R3d)
}
# read flight log
logVooFile = '80m_12m.s/2017-12-15 14-08-45.log'
cloudsDir = 'voo6/'
gpsFiles = dir(cloudsDir, pattern = '_gps.txt', full.names = T)
logVoo = read.table(logVooFile, head=F, as.is = T, sep=';')[,1]
gpsVelodyne = lapply(gpsFiles, read.table, header = F, as.is = T, sep=',')
gpsVelodyne = do.call(rbind, gpsVelodyne)
# isolate position and orientation rows
gps = logVoo[grepl('^GPS', logVoo)]
# imu = logVoo[grepl('^IMU,', logVoo)]
att = logVoo[grepl('^ATT', logVoo)]
# parse gps data
gps = as.data.frame(do.call(rbind, strsplit(gps, ', ', fixed = T)))
for(i in 2:ncol(gps)) gps[,i] = as.double(as.character(gps[,i]))
names(gps) = c('Sensor','TimeUS','Status','GMS','GWk','NSats','HDop','Lat','Lng','Alt','Spd','GCrs','VZ','U')
ord = order(gps$TimeUS)
gps = gps[ord,]
# project and convert gps to UTM
latLong = data.frame(lat = gps$Lat, lon = gps$Lng)
coordinates(latLong) = c('lon', 'lat')
proj4string(latLong) <- CRS("+init=epsg:4326")
res = spTransform(latLong, CRS("+init=epsg:22522"))
gps$utmLat = res@coords[,2]
gps$utmLng = res@coords[,1]
# parse attitude (orientation) data
att = as.data.frame(do.call(rbind, strsplit(att, ', ', fixed = T)))
for(i in 2:ncol(att)) att[,i] = as.double(as.character(att[,i]))
names(att) = c('Sensor', 'TimeUS','DesRoll','Roll','DesPitch','Pitch','DesYaw','Yaw','ErrRP','ErrYaw')
# calculate coordinates for each orientation
att = cbind(att, GMS = NA, xPos = NA, yPos = NA, zPos = NA, utmLat = NA, utmLng = NA)
for(i in 2:nrow(gps)){
# i = 2
pos1 = gps[i-1,]
pos2 = gps[i,]
timeDistance = pos2$TimeUS - pos1$TimeUS
# ATT
iRot = which(att$TimeUS < pos2$TimeUS & att$TimeUS >= pos1$TimeUS)
rotations = att[iRot,]
posRotation = (rotations$TimeUS - pos1$TimeUS)/timeDistance
GMS  = pos1$GMS + posRotation * (pos2$GMS - pos1$GMS)
xPos = pos1$Lng + posRotation * (pos2$Lng - pos1$Lng)
yPos = pos1$Lat + posRotation * (pos2$Lat - pos1$Lat)
zPos = pos1$Alt + posRotation * (pos2$Alt - pos1$Alt)
utmLat  = pos1$utmLat + posRotation * (pos2$utmLat - pos1$utmLat)
utmLng  = pos1$utmLng + posRotation * (pos2$utmLng - pos1$utmLng)
att[iRot,c('GMS', 'xPos', 'yPos', 'zPos','utmLat', 'utmLng')] = cbind(GMS, xPos, yPos, zPos, utmLat, utmLng)
}
att = att[!is.na(att$xPos),]
att$velodyneTimeStamp = predictTimeStamps(gpsVelodyne, att$GMS)
# windows()
# par(mfrow=c(1,3))
plot(att$Roll ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Roll, df=100)
lines(spl$x, spl$y, col='red')
att$Roll = spl$y
plot(att$Pitch ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Pitch, df = 100)
lines(spl$x, spl$y, col='red')
att$Pitch = spl$y
roughCh = with(att, which(Yaw[-1] - Yaw[-length(Yaw)] > 10))
roughYaw = att$velodyneTimeStamp[roughCh]
att$Yaw = ifelse(att$velodyneTimeStamp <= roughYaw, att$Yaw+360, att$Yaw)
plot(att$Yaw ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$Yaw, df=100)
lines(spl$x, spl$y, col='red')
att$Yaw = spl$y
plot(att$zPos ~ att$velodyneTimeStamp, pch=20, cex=.5)
spl = smooth.spline(att$velodyneTimeStamp, att$zPos, df=50)
lines(spl$x, spl$y, col='red')
att$zPos = spl$y
rm(gpsVelodyne, gps, latLong, res, logVoo)
# als = read.table('MDT_IPEF_2PTS.xyz')
# clear3d()
# rgl::plot3d(att[,c('utmLng', 'utmLat', 'zPos')], size=3, col='black', aspect = F)
# rgl.points(als, size=.5, col=cloud.col(als, topo.colors, 30))
# read point clouds
cloudFiles = sub(pattern = '_gps', '', gpsFiles)
pointCloud = lapply(cloudFiles, read.table, header = T, colClasses='numeric')
pointCloud = do.call(rbind, pointCloud)
# cross time and gps position
qt = quantile(1:nrow(pointCloud), probs = c(.1,.101))
firstCloud = pointCloud[qt[1]:qt[2],]
azim = firstCloud$azimuth
azim = mean(azim[ azim < 360])
azim = 45
yAngle = azim
rotMat = flightRotationMatrix(0,yAngle,0)
pointCloud[,c('x','y','z')] = as.matrix(pointCloud[,c('x','y','z')]) %*% rotMat
pointCloud$z = -pointCloud$z
getwd()
setwd('../Desktop/TLStools/')
require(lidR)
b = readLAS('lcer.las')
dt = read.table('lcer_result.txt', header = T)
head(dt)
require(rgl)
bg3d('black')
rgl.points(b@data, size=.5)
spheres3d(dt$x_average, dt$y_average, dt$z_min, dt$r_main, col='red')
# install and load necessary packages
if(!require(rgl)){
install.packages('rgl')
require(rgl)
}
if(!require(lidR)){
install.packages('lidR')
require(lidR)
}
# function for plotting 3d cylinders
plotCylinder = function(xCenter = 0, yCenter = 0, hBase = 0, hTop = 1, radius = 0.5, col = 'green'){
axis = matrix(c(
rep(xCenter, 2),
rep(yCenter, 2),
seq(hBase, hTop, length.out = 2)
), ncol = 3, byrow = F)
cyl = cylinder3d(axis, radius = radius)
# shade3d(addNormals(subdivision3d(cyl, depth = 0)), col = col)
mesh = shade3d(cyl, col=col)
}
# set working directory
setwd('C://Users/Tiago/Desktop/TLStools/bin/Release/')
# set point cloud name
cloudName = 'lcer.las'
# set optional parameters for the las2rings application
optionalParameters = ''
# read the output files generated in the process
cloud = readLAS(cloudName)
stemsCloud = readLAS('clouds/lcer_trees.laz')
layerStack = readLAS('clouds/lcer_segmt.laz')
treeStats = read.table('repo/lcer_reslt.txt', head=T)
open3d()
bg3d('black')
# --load the points from the detected tree positions on multiple stacked layers
rgl.points(layerStack@data, col='blue')
# --load the stem points
rgl.points(stemsCloud@data, col='darkred')
# load the original point cloud
rgl.points(cloud@data, col='white', size=.5)
# fast - plot spheres with the corresponding diameters for every detected tree segment, at the right coordinates
with(treeStats, spheres3d(x, y, (z_min + z_max) / 2, rad, col='yellow') )
# plot the axes
axes3d()
